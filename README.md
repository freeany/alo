## 路径

  1. 字符串
  2. 数组
  3. 栈/队列
  4. 链表
  5. 二叉树
  6. 哈希表
  7. 回溯
  8. 贪心
  9. 动态规划
  10. 其他杂七杂八

### 字符串

  1. 9.回文数 easy
     - (解法：左右双指针)
  2. 344.反转字符串 easy
     - (解法：左右双指针，与回文数一致)
  3. 541.反转字符串II easy
     - (for循环上动手脚，取最小值来满足题目要求的条件，一次满足, 记得要翻转k个，要-1， 否则就是翻转的k+1个)
  4. 459.重复的子字符串 easy
     - (解法：KMP)
  5. 3.无重复字符的最长子串 medium
      - (解法： 滑动窗口)

### 数组

  1. 704.二分查找
     - (解法：左右双指针，区间要弄清，如果是[]左闭右闭记得改变left+1/right-1， 如果是左闭右开，那么right不需要-1)
  2. 26.删除有序数组中的重复项
     - (解法： 快慢双指针，不等于做替换)
  3. 27.移除元素
     - (解法： 快慢双指针，不等于做替换)
  4. 283.移动零
     - (解法： 快慢双指针，不等于做交换)
  5. 167.两数之和 II - 输入有序数组
      - (解法： 左右双指针，因为是有序, 所以可以左边最小的+右边最大的与target进行对比，然后不断排除)
  6. 209.长度最小的子数组
      - (解法：滑动窗口 sum, subLen, result, startIndex)
  7. 349.两个数组的交集
      - (解法： 第一个数组去重，然后循环第二个数组，将有交集的放到一个新的set集合中，没啥难度)
  8. 977.有序数组的平方
      - (解法： 双指针解法，哪个大就unshift哪个， 为什么可以这么解，因为数组是有顺序的，所以两边其一肯定有最大的)

### 栈和队列

   匹配问题可是栈的强项

   1. 232.用栈实现队列
      - (队列是先进先出的特性，在js中对应的是容器数组的push的pop操作，但是如题要求用栈实现队列，所以要自己使用数组实现队列)
      - (使用一个输入栈和一个输出栈来模拟队列的行为)
      - (若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序)
   2. 225.用队列实现栈
      - (栈是先进后出，后进先出。单栈实现数组， 使用push和shift取头)
   3. 1047.删除字符串中的所有相邻重复项 - 栈
      - (想到栈解法即可， 对比然后pop就可以了)
   4. 20.有效的括号 - 栈
      - 很经典的问题，编译器的词法分析，以及模板的编译处理都用到了这种解法
      - (主要想到定义map, stack, brackets这三个数据，最后如果stack为空则说明正确)
   5. 71.简化路径 - 栈
      - (先想到用栈，然后将path用split('/') 分开)

### 链表

  当然首先要用js实现一个链表数据结构，了解链表理论基础之后再开始做
  链表题中比较常见的是定义虚拟头节点和快慢指针。

   1. 707.设计链表
      - (在constructor中定义哨兵节点和链表的长度，在增加/删除时++--，size主要用来进行判断提供的角标是否超过了链表的长度)
   2. 203.移除链表元素
      - (哨兵)
   3. 876.链表的中间结点
      - (解法一: 数组最简单)
      - (解法二：快慢指针)
   4. 24.两两交换链表中的节点
      - (哨兵，循环内部定义cur和prev)
   5. 19.删除链表的倒数第N个节点
      - (快慢指针)
   6. 141.环形链表
      - (快慢指针)
   7. 142.环形链表 II
      - (快慢指针)
   8. 146.LRU 缓存
      - (在constructor中定义max和cache map)
   9. 160.相交链表
      - (定义pA和pB两个指针，while判断!==)
   10. 2.两数相加
      - (注意十位数)
   11. 21.合并两个有序链表
      - (判断合并，没难度)
   12. 234.回文链表
      - (我采用的是最简单的方法，放入数组，然后通过数组判断回文)
   13. 237.删除链表中的节点
      - (既然不能删除自己，那就让自己变成next，然后在删除next，就完成了)
   14. 83.删除排序链表中的重复元素
      - (保存prev和prev的val然后判断即可，没难度)
   15. 206.反转链表
      - (双指针，curr和prev解法，还有递归解法)
   16. 92.反转链表 II
      - (记住反转完成后，prev是题目中要翻转节点的最后一个节点，curr要翻转节点的最后一个节点的next，记住这俩)

### 树
  了解树的概念和树的遍历方式
   94. 二叉树的中序遍历<br> 
   101. 对称二叉树<br> 
   102. 二叉树的层序遍历<br> 
   104. 二叉树的最大深度<br> 
   105. 从前序与中序遍历序列构造二叉树<br> 
   106. 从中序与后序遍历序列构造二叉树<br> 
   107. 二叉树的层序遍历 II<br> 
   108. 将有序数组转换为二叉搜索树<br> 
   109. 有序链表转换二叉搜索树<br> 
   110. 平衡二叉树<br> 
   111. 二叉树的最小深度<br> 
   112. 路径总和<br> 
   113. 路径总和 II<br> 
   114. 二叉树展开为链表<br> 
   116. 填充每个节点的下一个右侧节点指针<br> 
   117. 填充每个节点的下一个右侧节点指针 II<br> 
   124. 二叉树中的最大路径和<br> 
   144. 二叉树的前序遍历<br> 
   145. 二叉树的后序遍历<br> 
   199. 二叉树的右视图<br> 
   222. 完全二叉树的节点个数<br> 
   226. 翻转二叉树<br> 
   230. 二叉搜索树中第K小的元素<br> 
   236. 二叉树的最近公共祖先<br> 
   257. 二叉树的所有路径<br> 
   404. 左叶子之和<br> 
   429. N 叉树的层序遍历<br> 
   513. 找树左下角的值<br> 
   513. 找树左下角的值递归版<br> 
   515. 在每个树行中找最大值<br> 
   543. 二叉树的直径<br> 
   572. 另一棵树的子树<br> 
   617. 合并二叉树<br> 
   637. 二叉树的层平均值<br> 
   654. 最大二叉树<br> 
   700. 二叉搜索树中的搜索<br> 
   701. 二叉搜索树中的插入操作<br> 
   889. 根据前序和后序遍历构造二叉树<br> 
   98. 验证二叉搜索树<br> 
   99. 恢复二叉搜索树<br> 
   1008. 前序遍历构造二叉搜索树<br> 

